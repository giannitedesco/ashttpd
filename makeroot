#!/usr/bin/python

from sys import stdin, argv
import os, stat
import magic

# daim bar
globalmagic = magic.open(magic.MAGIC_MIME)
globalmagic.load()

class foostr(str):
	def __lt__(a, b):
		if len(a) < len(b):
			return True
		if len(a) > len(b):
			return False
		return str.__lt__(a, b)
	def __le__(a, b):
		if len(a) < len(b):
			return True
		if len(a) > len(b):
			return False
		return str.__le__(a, b)
	def __gt__(a, b):
		if len(a) > len(b):
			return True
		if len(a) < len(b):
			return False
		return str.__gt__(a, b)
	def __ge__(a, b):
		if len(a) > len(b):
			return True
		if len(a) < len(b):
			return False
		return str.__ge__(a, b)
	def __eq__(a, b):
		return str.__eq__(a, b)
	def __ne__(a, b):
		return str.__ne__(a, b)
	def __cmp__(a, b):
		if len(a) != len(b):
			return len(a) - len(b)
		return str.__cmp__(a, b)

class FileObject:
	def __lt__(a, b):
		return a.size < b.size
	def __le__(a, b):
		return a.size <= b.size
	def __gt__(a, b):
		return a.size > b.size
	def __ge__(a, b):
		return a.size >= b.size
	def __ne__(a, b):
		return a.size != b.size
	def __eq__(a, b):
		return a.size == b.size
	def __cmp__(a, b):
		return a.size - b.size

	def __init__(self, path):
		st = os.stat(path)
		key = (st.st_dev, st.st_ino)
		self.key = key
		self.path = path
		self.size = st.st_size
		self.mime_type = None
	def __str__(self):
		return self.path
	def to_file(self, f):
		self.fpos = f.tell()

		# TODO: write header

		infile = open(self.path)
		st = os.fstat(infile.fileno())
		if (st.st_dev, st.st_ino) != self.key:
			raise Exception("Rug pulling mayhem")
		buf = infile.read(8192)
		while buf:
			f.write(buf)
			buf = infile.read(8192)

		self.flen = f.tell() - self.fpos
	def set_mime_type(self, mime):
		self.mime_type = str(mime)

class ObjectStore:
	PATH_404 = "./404.html"

	def __init__(self):
		self.__obj_db = {}
		self.__404 = self.add()

	def get_404(self):
		return self.__404

	def add(self, path = None):
		if not path:
			path = self.PATH_404

		candidate = FileObject(path)
		key = candidate.key

		if self.__obj_db.has_key(key):
			ret = self.__obj_db[key]
			del candidate
		else:
			self.__obj_db[key] = candidate
			ret = candidate
			m = globalmagic
			ret.set_mime_type(m.file(ret.path))

		return ret

	def __dio_align(self, f):
		fd = f.fileno()
		st = os.fstat(fd)
		tail = f.tell() % st.st_blksize
		pad = st.st_blksize - tail
		print "blksize=%u tail=%u pad=%u"%(st.st_blksize, tail, pad)
		os.ftruncate(fd, st.st_size + pad)

	def write(self, fn):
		obj = self.__obj_db.values()
		obj.sort()
		f = open(fn, 'w')
		print "Writing object DB: %s"%fn
		for o in obj:
			o.to_file(f)
		self.__dio_align(f)
		return

class NameDB:
	def __init__(self):
		self.__names = {}
		self.__objects = ObjectStore()
	def __setitem__(self, key, val):
		self.__names[foostr(key)] = self.__objects.add(val)
	def __iter__(self):
		n = self.__names.keys()
		n.sort()
		return n.__iter__()

	# FIXME: use workset URI so that workset and non-workset data
	# can live together in same objdb
	def __workset(self):
		wsize = len(self.__names.keys())
		print "Workset size %u"%wsize
		dsize = len("%u"%(wsize - 1))

		moduli = []
		cur = 1
		for m in xrange(dsize):
			moduli.append(cur)
			cur *= 10
		moduli.reverse()
			
		n = 0
		newmap = {}
		for x in self.__names.keys():
			p = '/' + ('/'.join("%u"%((n / moduli[i]) % 10)
				for i in xrange(len(moduli)))) + '.html'
			newmap[foostr(p)] = self.__names[x]
			n += 1
		self.__names = newmap

	def write(self, obj_fn, ndb_fn, workset = False):
		self.__objects.write(obj_fn)

		f = open(ndb_fn, 'w')
		print "Writing name DB: %s"%ndb_fn

		if workset:
			self.__workset()

		o404 = self.__objects.get_404()

		mime = {o404.mime_type: o404}
		for n in self:
			o = self.__names[n]
			mime[o.mime_type] = None
		mimelist = mime.keys()
		mimelist.sort()
		f.write("static const char * const mime_types[] = {\n")
		for x in mimelist:
			f.write("\t\"%s\",\n"%x)
		f.write("};\n\n")

		f.write("static const struct webroot_name ")
		f.write("webroot_namedb[] = {\n")


		for n in self:
			o = self.__names[n]
			if o == o404:
				print "skipped: %s"%n
				continue
			f.write("\t{ ")
			f.write(".name = { .v_ptr = (uint8_t *)\"%s\",\n"%n)
			f.write("\t\t.v_len = %u},\n"%len(n))
			f.write("\t\t.mime_type = %u,\n"%mimelist.index(
							o.mime_type))
			f.write("\t\t.f_ofs = %u, .f_len = %u"%(o.fpos, o.flen))
			f.write(" },\n")
		f.write("};\n\n")

		f.write("const off_t obj404_f_ofs = %u;\n"%o404.fpos)
		f.write("const size_t obj404_f_len = %u;\n"%o404.flen)
		f.write("const unsigned int obj404_mime_type")
		f.write(" = %u;\n"%mimelist.index(o404.mime_type))
	
	def write_gidx_data(self, fn):
		f = open(fn, 'w')
		o404 = self.__objects.get_404()
		for n in self:
			o = self.__names[n]
			if o == o404:
				continue
			f.write("'%s', NULL, '%s', 0, %u, %u\n"%\
				(n, o.mime_type, o.fpos, o.flen))

def webmap(webroot, path):
	ret = os.path.join(webroot, path)

	try:
		st = os.stat(ret)
	except OSError:
		print "%s - 404"%ret
		return None

	if stat.S_ISDIR(st.st_mode):
		idx = os.path.join(ret, "index.html")
		try:
			st = os.stat(idx)
			return idx
		except OSError:
			return None

	return ret

if __name__ == '__main__':
	ws = False

	if len(argv) > 1:
		webroot = argv[1]
		if len(argv) > 2:
			ws = argv[2].lower() in ["ws", "workset", "wset"]
	else:
		webroot = '.'
	print "Webroot is %s"%webroot

	ndb = NameDB()
	for line in stdin:
		uri = line.rstrip("\r\n")
		path = uri.lstrip("/")
		ndb[uri] = webmap(webroot, path)
	
	ndb.write("webroot.objdb", "webroot.h", ws)
	ndb.write_gidx_data("webroot.gidx.data")
