#!/usr/bin/python

from sys import stdin, argv
import os, stat
import magic

# daim bar
globalmagic = magic.open(magic.MAGIC_MIME)
globalmagic.load()

class foostr(str):
	def __lt__(a, b):
		if len(a) < len(b):
			return True
		if len(a) > len(b):
			return False
		return str.__lt__(a, b)
	def __le__(a, b):
		if len(a) < len(b):
			return True
		if len(a) > len(b):
			return False
		return str.__le__(a, b)
	def __gt__(a, b):
		if len(a) > len(b):
			return True
		if len(a) < len(b):
			return False
		return str.__gt__(a, b)
	def __ge__(a, b):
		if len(a) > len(b):
			return True
		if len(a) < len(b):
			return False
		return str.__ge__(a, b)
	def __eq__(a, b):
		return str.__eq__(a, b)
	def __ne__(a, b):
		return str.__ne__(a, b)
	def __cmp__(a, b):
		if len(a) != len(b):
			return len(a) - len(b)
		return str.__cmp__(a, b)

class WebObject:
	def __lt__(a, b):
		return a.size < b.size
	def __le__(a, b):
		return a.size <= b.size
	def __gt__(a, b):
		return a.size > b.size
	def __ge__(a, b):
		return a.size >= b.size
	def __ne__(a, b):
		return a.size != b.size
	def __eq__(a, b):
		return a.size == b.size
	def __cmp__(a, b):
		return a.size - b.size
	def __str__(self):
		return self.path
	def __init__(self):
		self.mime_type = None
	def calc_mime_type(self):
		return
	def get_mime_type(self, mimelist):
		return "%d"%mimelist.index(self.mime_type)
	def value(self):
		return '.data = {.f_ofs = %u, .f_len = %u}}'%\
			(self.fpos, self.flen)

class FileObject(WebObject):
	def __init__(self, path):
		WebObject.__init__(self)
		st = os.stat(path)
		key = (st.st_dev, st.st_ino)
		self.key = key
		self.path = path
		self.size = st.st_size

	def to_file(self, f):
		self.fpos = f.tell()

		# TODO: write header

		infile = open(self.path)
		st = os.fstat(infile.fileno())
		if (st.st_dev, st.st_ino) != self.key:
			raise Exception("Rug pulling mayhem")
		buf = infile.read(8192)
		while buf:
			f.write(buf)
			buf = infile.read(8192)

		self.flen = f.tell() - self.fpos

	def calc_mime_type(self):
		m = globalmagic
		self.mime_type = str(m.file(self.path))

class DirObject(WebObject):
	def make_index(self):
		print 'Indexing %s'%self.path
		ret = '<html>'
		ret += '<head><title>Index of %s</title></head>'%self.key
		ret += '<body bgcolor="white"><h1>Dir index of %s</h1>'%self.key
		ret += '<hr>'

		# summary
		p = os.path.join(self.path, 'README.txt')
		try:
			f = open(p)
			s = '<pre>'
			s += f.read()
			s += '</pre><hr>'
			del f
		except Exception, e:
			s = ''
		ret += s

		# directory list
		ret += '<pre>'
		l = os.listdir(self.path)
		l.sort()
		for x in l:
			if x in ['.htaccess', '.htpasswd']:
				continue
			p = os.path.join(self.path, x)
			try:
				st = os.stat(p)
			except OSError:
				continue
			if stat.S_ISDIR(st.st_mode):
				x += '/'

			if stat.S_ISREG(st.st_mode):
				sz = '%d bytes'%st.st_size
			else:
				sz = '-'
			ln = '<a href="%s">%s</a>'%(x, x)
			ln += ('%%%ds'%(50 - len(x)))%sz
			ret += ln + '\n'

		ret += '</pre><hr>ashttpd, experimental l33tness'
		ret += '</body></html>'
		return ret

	def __init__(self, path, uri):
		WebObject.__init__(self)
		self.key = uri
		self.path = path
		self.__data = self.make_index()
		self.size = len(self.__data)
		self.mime_type = 'text/html; charset=us-ascii'

	def to_file(self, f):
		self.fpos = f.tell()
		f.write(self.__data)
		self.flen = f.tell() - self.fpos

class MovedObject(WebObject):
	def __init__(self, before, after):
		WebObject.__init__(self)
		self.key = before
		self.size = 0
		self.moved_to = after
		#print 'Redirect %s -> %s'%(before, after)

	def to_file(self, f):
		self.fpos = 0
		self.flen = 0
	def get_mime_type(self, mimelist):
		return "MIME_TYPE_MOVED_PERMANENTLY"
	def value(self):
		return '.moved = {.v_ptr = (uint8_t *)"%s", .v_len = %u}}'%\
			(str(self.moved_to), len(self.moved_to))

class ObjectStore:
	PATH_404 = "./404.html"

	def __init__(self):
		self.__obj_db = {}
		self.__404 = self.add_file()

	def get_404(self):
		return self.__404

	def __do_add(self, candidate):
		key = candidate.key

		if self.__obj_db.has_key(key):
			ret = self.__obj_db[key]
			del candidate
		else:
			self.__obj_db[key] = candidate
			ret = candidate
			ret.calc_mime_type()

		return ret

	def add_file(self, path = None):
		if not path:
			path = self.PATH_404

		return self.__do_add(FileObject(path))

	def add_dir(self, path, uri):
		assert(uri[-1:] == '/')
		return self.__do_add(DirObject(path, uri))
	def add_redirect(self, before, after):
		return self.__do_add(MovedObject(before, after))
	def __dio_align(self, f):
		fd = f.fileno()
		st = os.fstat(fd)
		tail = f.tell() % st.st_blksize
		pad = st.st_blksize - tail
		print "blksize=%u tail=%u pad=%u"%(st.st_blksize, tail, pad)
		os.ftruncate(fd, st.st_size + pad)

	def write(self, fn):
		obj = self.__obj_db.values()
		obj.sort()
		f = open(fn, 'w')
		print "Writing object DB: %s"%fn
		for o in obj:
			o.to_file(f)
		self.__dio_align(f)
		return

class NameDB:
	TYPE_FILE = 0
	TYPE_DIR = 1

	def __init__(self):
		self.__names = {}
		self.__objects = ObjectStore()
	def __setitem__(self, key, (ty, val)):
		if ty == self.TYPE_FILE:
			self.__names[foostr(key)] = \
				self.__objects.add_file(val)
		elif ty == self.TYPE_DIR:
			if key[-1:] != '/':
				key += '/'
			if key != '/':
				self.__names[foostr(key[:-1])] = \
					self.__objects.add_redirect(key[:-1], key)
			try:
				self.__names[foostr(key)] = \
					self.__objects.add_file(val + '/index.html')
			except OSError:
				self.__names[foostr(key)] = \
					self.__objects.add_dir(val, key)
		else:
			raise Exception
	def __iter__(self):
		n = self.__names.keys()
		n.sort()
		return n.__iter__()

	# FIXME: use workset URI so that workset and non-workset data
	# can live together in same objdb
	def __workset(self):
		wsize = len(self.__names.keys())
		print "Workset size %u"%wsize
		dsize = len("%u"%(wsize - 1))

		moduli = []
		cur = 1
		for m in xrange(dsize):
			moduli.append(cur)
			cur *= 10
		moduli.reverse()
			
		n = 0
		newmap = {}
		for x in self.__names.keys():
			p = '/' + ('/'.join("%u"%((n / moduli[i]) % 10)
				for i in xrange(len(moduli)))) + '.html'
			newmap[foostr(p)] = self.__names[x]
			n += 1
		self.__names = newmap

	def write(self, obj_fn, ndb_fn, workset = False):
		self.__objects.write(obj_fn)

		f = open(ndb_fn, 'w')
		print "Writing name DB: %s"%ndb_fn

		if workset:
			self.__workset()

		o404 = self.__objects.get_404()

		mime = {o404.mime_type: o404}
		for n in self:
			o = self.__names[n]
			mime[o.mime_type] = None
		mimelist = mime.keys()
		mimelist.sort()
		f.write("static const char * const mime_types[] = {\n")
		for x in mimelist:
			f.write("\t\"%s\",\n"%x)
		f.write("};\n\n")

		f.write("static const struct webroot_name ")
		f.write("webroot_namedb[] = {\n")


		for n in self:
			o = self.__names[n]
			if o == o404:
				print "skipped: %s"%n
				continue
			f.write("\t{ ")
			f.write(".name = { .v_ptr = (uint8_t *)\"%s\",\n"%n)
			f.write("\t\t.v_len = %u},\n"%len(n))
			f.write("\t\t.mime_type = %s,\n"%\
				o.get_mime_type(mimelist))
			f.write("\t\t.u = {%s},\n"%o.value())
		f.write("};\n\n")

		f.write("const off_t obj404_f_ofs = %u;\n"%o404.fpos)
		f.write("const size_t obj404_f_len = %u;\n"%o404.flen)
		f.write("const unsigned int obj404_mime_type")
		f.write(" = %u;\n"%mimelist.index(o404.mime_type))
	
	def write_gidx_data(self, fn):
		f = open(fn, 'w')
		o404 = self.__objects.get_404()
		for n in self:
			o = self.__names[n]
			if o == o404:
				continue
			#f.write("'%s', NULL, '%s', 0, %u, %u\n"%\
			#	(n, o.mime_type, o.fpos, o.flen))
			f.write("'%s'\n"%n)

def webmap(webroot, path):
	ret = os.path.join(webroot, path)

	try:
		st = os.stat(ret)
	except OSError:
		print "%s - 404"%ret
		return (NameDB.TYPE_FILE, None)

	if stat.S_ISDIR(st.st_mode):
		return (NameDB.TYPE_DIR, ret)

	return (NameDB.TYPE_FILE, ret)

if __name__ == '__main__':
	ws = False

	if len(argv) > 1:
		webroot = argv[1]
		if len(argv) > 2:
			ws = argv[2].lower() in ["ws", "workset", "wset"]
	else:
		webroot = '.'
	print "Webroot is %s"%webroot

	ndb = NameDB()
	for line in stdin:
		uri = line.rstrip("\r\n")
		path = uri.lstrip("/")
		ndb[uri] = webmap(webroot, path)
	
	ndb.write("webroot.objdb", "webroot.h", ws)
	ndb.write_gidx_data("webroot.gidx.data")
